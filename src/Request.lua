---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by benjamin.
--- DateTime: 1/04/22 14:18
---

local headersM = require 'http.headers'
local HttpUtils = require 'http.util'


---@module Request
function Request(stream)
    local self = {} -- @module Request
    local requestHeaders = stream:get_headers() -- request headers
    local responseHeaders = headersM.new() -- response headers

    -- Get request headers
    ---@param headerKey string Key of header
    ---@return string Value of header
    self.getRequestHeader = function(headerKey)
        return requestHeaders:get(headerKey)
    end

    ---Set response headers
    ---@param headers table Table of headers
    ---@param endStream boolean End of stream
    self.setResponseHeaders = function(headers)
        for headerKey, headerValue in pairs(headers) do
            responseHeaders:delete(headerKey) -- delete old header if exists to authorize replace
            responseHeaders:append(headerKey, tostring(headerValue)) -- append header to response headers table
        end
    end

    ---Set response body
    --- TODO : Hide to handler
    ---@param body string Body of response
    self.write = function(body)
        addCookieHeader(responseHeaders, self.cookie)
        stream:write_headers(responseHeaders, self.getRequestHeader(':method') == 'HEAD') -- write response headers
        stream:write_chunk(body, true) -- write response body
    end

    self.flush = function()
        addCookieHeader(responseHeaders, self.cookie)
        stream:write_headers(responseHeaders, self.getRequestHeader(':method') == 'HEAD') -- write response headers
        stream:write_chunk("", true)
    end

    -- Plain path : with query string
    local plainSecuredPath = self.getRequestHeader(':path') or '/'
    plainSecuredPath = HttpUtils.decodeURI(plainSecuredPath) -- decode URI to plain path

    ---Request path without query string
    ---@type string
    self.path = getPath(plainSecuredPath)

    ---Request query string (Data of GET request)
    ---@type table
    self.get = getGetData(plainSecuredPath)

    ---Request body (Data of POST request)
    ---@type table
    self.post = getPostData(self, stream)

    ---Cookies of request (Data of Cookie request).
    ---@type table
    self.cookie = getCookies(self)

    return self
end

--- Methode that secure path and return secure path
---@param path string Path to secure
---@return string Secure path
function securePath(path)
    -- Secure path to avoid path traversal attack (e.g. /../../etc/passwd)
    path = path:gsub('/[^/]*/%.%./', '/')

    return path
end


-- Function that return path without query string (e.g. /path?a=1&b=2 => /path)
function getPath(path)
    local path = path:match('^(.*)%?') or path
    return path
end


--- Method that extract get data from request path and return it as table of key/value pairs
---@return table
function getGetData(path)
    local getData = {}

    if path:find('?') then
        local getDataString = path:sub(path:find('?') + 1)
        for key, value in string.gmatch(getDataString, '([^&]+)=([^&]+)') do
            -- Decode value to protect from XSS
            getData[HttpUtils.decodeURIComponent(key)] = HttpUtils.decodeURIComponent(value)
        end
    end
    return getData
end


-- Method that extract post data from request body and return it as table of key/value pairs
-- Adapt traitment of body data depending of content-type header (application/x-www-form-urlencoded or multipart/form-data or other)
--@param request Request object
--@param stream Stream of request (use to get body data)
--@return table|string Post data
function getPostData(request, stream)
    local postData = {}

    -- Get content-type header and parse it to get content-type value without boundary (e.g. multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW -> multipart/form-data)
    local contentType = request.getRequestHeader('content-type') or ''
    contentType = contentType:match('^([^;]+)') or ''

    if contentType == 'application/x-www-form-urlencoded' then
        local postDataString = stream:get_body_as_string()
        for key, value in string.gmatch(postDataString, '([^&]+)=([^&]+)') do
            -- Decode value to protect from XSS
            postData[HttpUtils.decodeURIComponent(key)] = HttpUtils.decodeURIComponent(value)
        end
    elseif contentType == 'multipart/form-data' then
        local postDataString = stream:get_body_as_string()

        -- Get boundary value
        local boundary = request.getRequestHeader('content-type'):match('boundary=([^;]+)') or ''
        postData = getMultipartFormData(postDataString, boundary)

    else
        postData = stream:get_body_as_string()
    end

    return postData
end


--- Method that extract cookies from request and return it as table of key/value pairs
---@param request Request Request object
---@return table Cookies data
function getCookies(request)
    local cookies = {}
    local cookieString = request.getRequestHeader('cookie') or ''

    for key, value in string.gmatch(cookieString, '([^;]+)=([^;]+)') do
        cookies[key] = value
    end
    return cookies
end


--- Method that add cookies to response headers table (if not exists) as key value
---@param responseHeaders table Response headers object
---@param cookies table Cookies data
function addCookieHeader(responseHeaders, cookies)
    for key, value in pairs(cookies) do
        if not responseHeaders:get('Set-Cookie') then
            responseHeaders:append('Set-Cookie', key .. '=' .. value)
        else
            responseHeaders:append('Set-Cookie', '; ' .. key .. '=' .. value)
        end
    end
end


--- Method that extract multipart/form-data data from request body and return it as table of key/value pairs
---@param postDataString string Body of request
---@return table Multipart/form-data data
function getMultipartFormData(postDataString, boundary)
    local postData = {}

    return postData
end



return {
    new = Request
}